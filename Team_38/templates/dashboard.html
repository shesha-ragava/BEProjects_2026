{% extends "base.html" %}

{% block title %}Dashboard - SentimentScope{% endblock %}

{% block head_extra %}
<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
{% endblock %}

{% block content %}
<div class="row g-3">
  <!-- Left column: Sentiment chart -->
  <div class="col-lg-4">
    <div class="card shadow-sm border-0 rounded-4 h-100">
      <div class="card-body">
        <h5 class="card-title mb-3 fw-semibold">Sentiment Overview</h5>
        <p class="text-muted small mb-3">
          Distribution of positive, negative, and neutral posts from your latest Reddit fetch.
        </p>
        <div class="chart-container">
          <canvas id="sentimentChart"></canvas>
        </div>
        <div class="mt-3 d-flex justify-content-end">
          <button
            id="show-all-posts"
            type="button"
            class="btn btn-outline-light btn-sm"
          >
            Show all posts
          </button>
        </div>
      </div>
    </div>
  </div>

    <!-- Right column: Chat interface -->
  <div class="col-lg-8">
    <div class="card shadow-sm border-0 rounded-4 h-100 d-flex flex-column">
      <div class="card-body d-flex flex-column">
        <h5 class="card-title mb-3 fw-semibold">Sentiment Chat</h5>
        <p class="text-muted small mb-3">
          Ask about any topic. I’ll either fetch and analyze fresh Reddit posts or answer questions based on your latest analysis.
        </p>

        <div class="chat-window mb-3 flex-grow-1" id="chat-window">
          <div class="chat-message system">
            <div class="bubble">
              Hi {{ user.username }}, ask me what Reddit feels about anything — just type your query below and hit Send!
            </div>
          </div>
        </div>

        <form id="query-form" class="mt-2">
          <div class="input-group">
            <textarea
              class="form-control"
              id="user_query"
              name="user_query"
              rows="1"
              placeholder="e.g., What does Reddit think about electric vehicles in India?"
            ></textarea>
            <button class="btn btn-primary" type="submit">Send</button>
          </div>
        </form>
      </div>
    </div>
  </div>

{% endblock %}

{% block scripts %}
{{ super() }}
<script>
  // Initial counts passed from Flask (may be all 0)
  const sentimentCounts = JSON.parse(
    '{{ (sentiment_counts | default({"positive": 0, "negative": 0, "neutral": 0})) | tojson | safe }}'
  );

  const ctx = document.getElementById("sentimentChart").getContext("2d");

  const sentimentChart = new Chart(ctx, {
    type: "doughnut",
    data: {
      labels: ["Positive", "Negative", "Neutral"],
      datasets: [
        {
          data: [
            sentimentCounts.positive,
            sentimentCounts.negative,
            sentimentCounts.neutral,
          ],
          backgroundColor: ["#22c55e", "#ef4444", "#6b7280"],
          hoverOffset: 6,
        },
      ],
    },
    options: {
      plugins: {
        legend: {
          position: "bottom",
        },
      },
      cutout: "65%",
      onClick: (evt, elements) => {
        if (!elements || !elements.length) return;
        const index = elements[0].index;
        const label = sentimentChart.data.labels[index]; // "Positive" | "Negative" | "Neutral"
        if (!lastPosts || lastPosts.length === 0) return;

        const sentimentKey = label.toLowerCase(); // "positive" etc.
        renderPosts(sentimentKey);
      },
    },
  });

  const showAllBtn = document.getElementById("show-all-posts");
  if (showAllBtn) {
    showAllBtn.addEventListener("click", () => {
      if (!lastPosts || lastPosts.length === 0) return;
      renderPosts(null);
    });
  }

  const chatWindow = document.getElementById("chat-window");
  const queryForm = document.getElementById("query-form");
  const queryInput = document.getElementById("user_query");

  // State for latest analysis
  let lastPosts = [];
  let lastQuery = "";
  let lastCounts = sentimentCounts;
  let lastFilter = null; // "positive" | "negative" | "neutral" | null

  // We'll reuse a single bot message bubble to render results
  let resultsMessageDiv = null;

  // Format LLM plain-text into safe HTML while keeping line breaks
  function formatPlainTextToHtml(text) {
  if (!text) return "";

  // Escape HTML tags first
  let escaped = text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");

  // Convert **bold** markdown to <strong>
  escaped = escaped.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");

  // Replace double newlines with paragraph breaks
  escaped = escaped
    .replace(/\r\n/g, "\n")
    .replace(/\n{2,}/g, "<br><br>") // blank lines
    .replace(/\n/g, "<br>"); // single newlines

  return escaped;
  }

  // Enter to send, Shift+Enter for newline
  queryInput.addEventListener("keydown", function (e) {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault(); // prevent newline
      queryForm.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
    }
  });

  function appendMessage(role, html) {
    const div = document.createElement("div");
    div.className = `chat-message ${role}`;
    div.innerHTML = `<div class="bubble">${html}</div>`;
    chatWindow.appendChild(div);
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }


  function renderPosts(filterSentiment = null) {
    if (!lastPosts || lastPosts.length === 0) {
      appendMessage(
        "bot",
        "No posts to display yet. Run an analysis first to see results."
      );
      return;
    }

    lastFilter = filterSentiment;

    const filteredPosts = filterSentiment
      ? lastPosts.filter((p) => p.sentiment === filterSentiment)
      : lastPosts;

    const total = lastPosts.length;
    const filteredCount = filteredPosts.length;

    const counts = lastCounts || {
      positive: 0,
      negative: 0,
      neutral: 0,
    };

    let header = "";

    if (!filterSentiment) {
      header = `
        I fetched and analyzed <strong>${total}</strong> Reddit posts for "<strong>${lastQuery}</strong>".
        <br>
        Sentiment breakdown:
        <br>
        Positive: <strong>${counts.positive || 0}</strong>,
        Negative: <strong>${counts.negative || 0}</strong>,
        Neutral: <strong>${counts.neutral || 0}</strong>.
      `;
    } else {
      const label =
        filterSentiment.charAt(0).toUpperCase() + filterSentiment.slice(1);
      header = `
        Showing <strong>${label}</strong> posts (<strong>${filteredCount}</strong> of ${total}) for "<strong>${lastQuery}</strong>".
        <br>
        Click the chart or "Show all posts" to change the filter.
      `;
    }

    let html = `
      ${header}
      <hr>
      <div class="results-list">
        <ul class="list-unstyled small mb-0">
    `;

    filteredPosts.forEach((p, idx) => {
      const sentimentClass =
        p.sentiment === "positive"
          ? "bg-success"
          : p.sentiment === "negative"
          ? "bg-danger"
          : "bg-secondary";

      const safeTitle = p.title || "(no title)";
      const snippet =
        (p.selftext || "").replace(/\s+/g, " ").slice(0, 160) +
        (p.selftext && p.selftext.length > 160 ? "..." : "");

      const postUrl = p.permalink || p.url || "#";

      html += `
        <li class="mb-2">
          <span class="badge rounded-pill ${sentimentClass} me-1">${p.sentiment}</span>
          <strong>#${idx + 1}</strong>
          <strong>r/${p.subreddit}</strong>:
          <a href="${postUrl}" target="_blank" rel="noopener noreferrer">
            ${safeTitle}
          </a>
          ${
            snippet
              ? `<br><span class="text-muted">${snippet}</span>`
              : ""
          }
        </li>
      `;
    });

    html += `
        </ul>
      </div>
    `;

    // Use a single reusable bot message bubble for the results
    if (!resultsMessageDiv) {
      resultsMessageDiv = document.createElement("div");
      resultsMessageDiv.className = "chat-message bot";
      resultsMessageDiv.innerHTML = `<div class="bubble"></div>`;
      chatWindow.appendChild(resultsMessageDiv);
    }

    const bubble = resultsMessageDiv.querySelector(".bubble");
    bubble.innerHTML = html;
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  queryForm.addEventListener("submit", async function (e) {
    e.preventDefault();
    const text = queryInput.value.trim();
    if (!text) return;

    // Show user message
    appendMessage("user", text);

    // Show temporary "thinking" message
    const loadingDiv = document.createElement("div");
    loadingDiv.className = "chat-message bot";
    loadingDiv.innerHTML = `
      <div class="bubble d-flex align-items-center">
        <div class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></div>
        <span>Thinking...</span>
      </div>
    `;
    chatWindow.appendChild(loadingDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;

    queryInput.value = "";

    try {
      const response = await fetch("{{ url_for('api_chat') }}", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          message: text,
          limit: 100,
        }),
      });

      const data = await response.json();

      // Remove loading bubble
      loadingDiv.remove();

      if (!response.ok) {
        const errMsg = data.error || "Something went wrong while analyzing sentiment.";
        appendMessage("bot", errMsg);
        return;
      }

      // For this step, mode is always "fetch_posts"
      if (data.mode === "fetch_posts") {
        const counts = data.sentiment_counts || {
          positive: 0,
          negative: 0,
          neutral: 0,
        };

        // Update chart
        sentimentChart.data.datasets[0].data = [
          counts.positive || 0,
          counts.negative || 0,
          counts.neutral || 0,
        ];
        sentimentChart.update();

        const posts = data.posts || [];

        // Save latest state for filtering
        lastPosts = posts;
        lastQuery = data.query || "";
        lastCounts = counts;
        lastFilter = null;

        // New fetch -> create a fresh results bubble
        resultsMessageDiv = null;
        renderPosts(null);
        } else if (data.mode === "qna") {
          const answerText =
            data.answer ||
            "I couldn't generate a detailed answer from the current analysis.";
          const formatted = formatPlainTextToHtml(answerText);
          appendMessage("bot", formatted);
        } else {
        appendMessage("bot", "I got an unexpected response mode from the server.");
      }
    } catch (err) {
      console.error(err);
      loadingDiv.remove();
      appendMessage(
        "bot",
        "Unexpected error while contacting the server. Please try again."
      );
    }
  });
</script>
{% endblock %}


